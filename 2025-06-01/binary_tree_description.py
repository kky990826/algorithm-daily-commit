"""
완전 이진 트리는 직접 클래스를 구현해서 사용하는 방법이 있고 배열로 표현하는 방법이 있음

배열로 표현하는 방법은 완전 이진 트리를 쓰는 경우에 한해서 가능

트리를 구현할 때는 편의성을 위해 0번째 인덱스는 사용되지 않음!
그래서 None 값을 배열에 넣고 시작 [None]

      8      Level 0 -> [None, 8] 첫번째 레벨의 8을 넣고,
    6   3    Level 1 -> [None, 8, 6, 3] 다음 레벨인 6, 3을 넣고
   4 2 5     Level 2 -> [None, 8, 6, 3, 4, 2, 5] 다음 레벨인 4, 2, 5를 넣으면 된다!

자 그러면, [None, 8, 6, 3, 4, 2, 5] 라는 배열이 되는데
다시 역으로 이 배열을 활용해서 트리 구조를 분석.
다음과 같은 방법으로 트리 구조를 파악할 수 있음.


  0    1  2  3  4  5  6
[None, 8, 6, 3, 4, 2, 5]

 level 0 / 1   / 2
  0  / 1 /2  3 /4  5  6
[None, 8, 6, 3, 4, 2, 5]

1. 현재 인덱스 * 2 -> 왼쪽 자식의 인덱스
2. 현재 인덱스 * 2 + 1 -> 오른쪽 자식의 인덱스 1 * 2 + 1 =3
3. 현재 인덱스 // 2 -> 부모의 인덱스

예를 들어서 1번째 인덱스인 8의 왼쪽 자식은 6, 오른쪽 자식은 3
그러면 1 * 2 = 2번째 인덱스! 6!
그러면 1 * 2 + 1 = 3번째 인덱스! 3!
부모를 찾아보면, 3 // 2 = 1번째 인덱스 8 이므로 부모를 찾을 수 있음.

이를 다시 생각해보면
[None, 8, 6, 3, 4, 2, 5] 는
8 밑에 6, 3 이 있고, 6, 3 밑에 4, 2, 5가 있는 완전 이진 트리구나! 생각할 수 있다.


완전 이진 트리의 시간복잡도는 O(logN)
이유는 완전 이진 트리인 경우에는 높이가 h인 경우 최대 노드의 개수는 2(h+1) -1 <공비수열의 합>
이것을 h에 대해서 풀이해보면 h = log2(N + 1) -1이 된다
즉 완전 이진 트리 노드의 개수가 N일때 트리의 높이는 최대로 해봤자 O(logN)이 된다는 것이다
"""